import { Storage } from '@google-cloud/storage';
import * as Busboy from 'busboy';
import { readFileSync, createWriteStream, unlinkSync } from 'fs';
import { createVerify } from 'crypto';
import * as path from 'path';

// Initialize Google Cloud Storage client
const storage = new Storage();
const bucketName = 'your-bucket-name';
const bucket = storage.bucket(bucketName);
const publicKey = readFileSync('path-to-your-public.pem', 'utf8');

function minus(mins: number): string {
  const current_time = Date.now();
  const new_time = current_time - (mins * 60 * 1000);
  const formatted_time = new Date(new_time).toISOString().slice(0, 16);
  return formatted_time;
}

async function verifySignature(content: string, signature: Buffer, publicKey: string): Promise<boolean> {
  const verifier = createVerify('SHA256');
  verifier.update(content);
  verifier.end();
  return verifier.verify(publicKey, signature);
}

export const handleFileUpload = async (req: any, res: any) => {
  if (req.method === 'POST') {
    const busboy = new Busboy({ headers: req.headers });
    const fields: any = {};
    const files: any = {};

    busboy.on('file', (fieldname, file, filename, encoding, mimetype) => {
      const saveTo = path.join('/tmp', path.basename(filename));
      files[fieldname] = saveTo;
      file.pipe(createWriteStream(saveTo));
    });

    busboy.on('field', (fieldname, val) => {
      fields[fieldname] = val;
    });

    busboy.on('finish', async () => {
      if (fields.namo && files.signature && fields.datesigned && fields.submit && files.content) {
        try {
          const namo = fields.namo;
          const namofile = `msgs/${namo}.js.js`;
          const namofileSign = `msgs/${namo}.js.js`;

          // Upload content file to GCS
          await bucket.upload(files.content, { destination: namofile });

          // Upload signature file to GCS
          await bucket.upload(files.signature, { destination: namofileSign });

          // Read files from GCS
          const [contentFileData] = await bucket.file(namofile).download();
          const content = contentFileData.toString();
          const [signatureFileData] = await bucket.file(namofileSign).download();
          const signature = Buffer.from(signatureFileData.toString(), 'base64');

          const okContent = await verifySignature(content, signature, publicKey);
          if (okContent) {
            let ok = false;
            let fecha2 = new Date().toISOString().slice(0, 16);
            let mins = 1;

            while (!ok && mins < 5) {
              ok = await verifySignature(fecha2, Buffer.from(fields.datesigned, 'base64'), publicKey);
              fecha2 = minus(mins++);
            }

            if (ok) {
              const filename = `msgs/${fields.namo}.js.js`;
              const contentout = Buffer.from(content, 'base64').toString();

              // Write file to GCS
              const file = bucket.file(filename);
              await file.save(contentout);

              res.writeHead(200, { 'Content-Type': 'application/json' });
              res.end(JSON.stringify({ error: `Success, wrote (${content}) to file (${filename})` }));
            } else {
              res.writeHead(400, { 'Content-Type': 'application/json' });
              res.end(JSON.stringify({ error: 'Could not decrypt' }));
            }
          } else {
            res.writeHead(400, { 'Content-Type': 'application/json' });
            res.end(JSON.stringify({ error: 'Data Mismatch' }));
          }
        } catch (err) {
          res.writeHead(500, { 'Content-Type': 'application/json' });
          res.end(JSON.stringify({ error: err.message }));
        } finally {
          // Clean up uploaded files
          unlinkSync(files.content);
          unlinkSync(files.signature);
        }
      } else {
        res.writeHead(400, { 'Content-Type': 'application/json' });
        res.end(JSON.stringify({ error: 'Missing Arguments' }));
      }
    });

    req.pipe(busboy);
  } else {
    res.writeHead(405, { 'Content-Type': 'application/json' });
    res.end(JSON.stringify({ error: 'Method Not Allowed' }));
  }
};
